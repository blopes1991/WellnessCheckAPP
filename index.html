<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="theme-color" content="#123b3a">
  <title>Wellness Check</title>
  <link rel="manifest" href="manifest.json">
  <style>
    :root {
      --bg: #f2f6f4;
      --card: #ffffff;
      --ink: #172b2a;
      --muted: #4d6c6a;
      --line: #c8d8d3;
      --accent: #156f63;
      --accent-soft: #d7f0ea;
      --warn-soft: #fee2e2;
      --warn-ink: #9f1239;
      --radius: 16px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Avenir Next", "Segoe UI", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(circle at top right, #d7efe8 0%, transparent 45%),
        radial-gradient(circle at bottom left, #fdeed8 0%, transparent 40%),
        var(--bg);
      min-height: 100vh;
      overflow-x: hidden;
    }
    main {
      max-width: 860px;
      margin: 0 auto;
      padding: 20px 14px 32px;
      display: grid;
      gap: 14px;
      overflow-x: clip;
    }
    .hero {
      padding: 16px 18px;
      border-radius: var(--radius);
      background: linear-gradient(135deg, #0f5a52 0%, #1c8b7d 100%);
      color: #f6fffd;
    }
    h1, h2, h3, p { margin: 0; }
    .hero h1 { font-size: 1.4rem; letter-spacing: 0.01em; margin-bottom: 6px; }
    .hero p { color: #d8f8f1; font-size: 0.95rem; }
    .card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 14px;
      box-shadow: 0 4px 18px rgba(13, 52, 48, 0.06);
      min-width: 0;
    }
    .section-title { font-size: 1rem; margin-bottom: 10px; }
    form { display: grid; gap: 10px; }
    .row { display: grid; gap: 10px; grid-template-columns: repeat(2, minmax(0, 1fr)); }
    label { display: grid; gap: 5px; font-size: 0.85rem; color: var(--muted); }
    input, select, button { font: inherit; }
    input, select {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px;
      color: var(--ink);
      background: #fff;
    }
    button { border: 0; border-radius: 10px; padding: 10px 12px; cursor: pointer; font-weight: 600; }
    .btn-main { background: var(--accent); color: #fff; }
    .btn-light { background: var(--accent-soft); color: #0b443d; }
    .btn-danger { background: #fee2e2; color: #9f1239; }
    .chart-wrap {
      width: 100%;
      min-width: 0;
      overflow-x: auto;
      overflow-y: hidden;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #fcfffe;
      -webkit-overflow-scrolling: touch;
      max-width: 100%;
    }
    .chart-inner {
      min-width: 100%;
      height: 280px;
      max-width: none;
    }
    .chart-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }
    .chart-range-tabs {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .range-tab {
      border: 1px solid var(--line);
      background: #f3fbf8;
      color: #21544e;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 0.8rem;
      font-weight: 600;
      line-height: 1;
    }
    .range-tab.active {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }
    #tempChart { width: 100%; min-height: 260px; display: block; }
    .insight-grid {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      margin-top: 10px;
    }
    .insight-head {
      margin-top: 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .btn-info {
      background: #e8f4f1;
      color: #1f5b54;
      border: 1px solid #bddad2;
      padding: 6px 10px;
      font-size: 0.8rem;
    }
    .section-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 10px;
    }
    .info-panel {
      margin-top: 8px;
      border: 1px solid var(--line);
      background: #f8fcfb;
      border-radius: 10px;
      padding: 10px;
      font-size: 0.82rem;
      color: #2f4f4b;
    }
    .info-panel[hidden] { display: none; }
    .insight { background: #f7fbf9; border: 1px solid var(--line); border-radius: 10px; padding: 10px; }
    .insight .k {
      color: var(--muted);
      font-size: 0.75rem;
      margin-bottom: 3px;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }
    .insight .v { font-weight: 700; font-size: 0.95rem; }
    .muted { color: var(--muted); font-size: 0.85rem; margin-top: 8px; }
    .list { margin-top: 10px; display: grid; gap: 8px; }
    .list-title {
      margin-top: 12px;
      margin-bottom: 6px;
      font-size: 0.9rem;
      color: var(--muted);
      font-weight: 600;
    }
    .month-group {
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #fbfffd;
      overflow: hidden;
    }
    .month-group summary {
      list-style: none;
      cursor: pointer;
      padding: 10px 12px;
      font-weight: 600;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      background: #f1f8f5;
      color: #1d4a45;
    }
    .month-group summary::-webkit-details-marker { display: none; }
    .month-group .count {
      font-size: 0.78rem;
      color: var(--muted);
      font-weight: 500;
    }
    .month-group .month-entries {
      padding: 8px;
      display: grid;
      gap: 6px;
    }
    .year-group {
      border: 1px solid #b7d2cb;
      border-radius: 12px;
      background: #f4fbf8;
      overflow: hidden;
    }
    .year-group > summary {
      list-style: none;
      cursor: pointer;
      padding: 11px 12px;
      font-weight: 700;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      background: #e4f3ee;
      color: #1f504a;
    }
    .year-group > summary::-webkit-details-marker { display: none; }
    .year-group .year-entries {
      padding: 8px;
      display: grid;
      gap: 8px;
    }
    .entry {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      display: flex;
      justify-content: space-between;
      gap: 8px;
      align-items: center;
      background: #fbfffd;
    }
    .entry small { color: var(--muted); display: block; margin-top: 2px; }
    .entry button {
      background: var(--warn-soft);
      color: var(--warn-ink);
      padding: 7px 10px;
      font-size: 0.8rem;
      white-space: nowrap;
    }
    @media (max-width: 640px) {
      .row { grid-template-columns: 1fr; }
      .chart-header {
        flex-direction: column;
        align-items: stretch;
      }
      .chart-range-tabs { justify-content: flex-start; }
    }
  </style>
</head>
<body>
  <main>
    <section class="hero">
      <h1>Wellness Check</h1>
      <p>Simple daily tracking for cycle and fertility patterns.</p>
    </section>
    <section class="card">
      <div class="section-head">
        <h2 class="section-title" style="margin:0;">Daily Basal Temperature</h2>
        <button id="tempInfoBtn" type="button" class="btn-info">Info</button>
      </div>
      <div id="tempInfoPanel" class="info-panel" hidden>
        <strong><u>About This Section</u></strong><br>
        <br>
        This section is for your Basal Body Temperature (BBT), which is your resting temperature right after waking up.<br>
        <br>
        <strong>How to take it correctly:</strong><br>
        1. Take it immediately after waking, before getting out of bed.<br>
        2. Take it at about the same time each morning.<br>
        3. Use the same thermometer each day.<br>
        4. Record the value right away in this app.<br>
        <br>
        Consistent timing helps make your chart more accurate and easier to interpret.
      </div>
      <form id="tempForm">
        <div class="row">
          <label>Date<input id="tempDate" type="date" required></label>
          <label>Temperature<input id="tempValue" type="number" inputmode="decimal" step="0.01" required placeholder="e.g. 97.56"></label>
        </div>
        <div class="row">
          <label>Unit<select id="tempUnit"><option value="F">Fahrenheit (F)</option><option value="C">Celsius (C)</option></select></label>
          <div style="display:grid;align-items:end;"><button class="btn-main" type="submit">Save Temperature</button></div>
        </div>
      </form>
    </section>
    <section class="card">
      <div class="section-head">
        <h2 class="section-title" style="margin:0;">Period Dates</h2>
        <button id="periodInfoBtn" type="button" class="btn-info">Info</button>
      </div>
      <div id="periodInfoPanel" class="info-panel" hidden>
        <strong><u>About This Section</u></strong><br>
        <br>
        Use this section to log the start and end of each period. This helps estimate cycle length and future fertile windows.<br>
        <br>
        <strong>How to use it:</strong><br>
        1. Log the first day of bleeding using Start date.<br>
        2. When bleeding ends, log End date later.<br>
        3. The app pairs them into one period range automatically.<br>
        <br>
        <strong>Helpful tips:</strong><br>
        1. Enter dates as soon as possible for better accuracy.<br>
        2. If bleeding patterns are unusual, still log what happened to keep your history complete.<br>
        3. For the best results, consider sharing your tracked data with your medical professional so they can provide personalized guidance.
      </div>
      <form id="periodForm">
        <div class="row">
          <label>Start date<input id="periodStart" type="date"></label>
          <div style="display:grid;align-items:end;"><button id="periodStartBtn" class="btn-main" type="button">Log Period Start</button></div>
        </div>
        <div class="row">
          <label>End date<input id="periodEnd" type="date"></label>
          <div style="display:grid;align-items:end;"><button id="periodEndBtn" class="btn-main" type="button">Log Period End</button></div>
        </div>
      </form>
      <p id="periodDraftStatus" class="muted"></p>
      <p class="muted">Period ranges are highlighted on the chart.</p>
    </section>
    <section class="card">
      <div class="section-head">
        <h2 class="section-title" style="margin:0;">Conception Tracking</h2>
        <button id="inseminationInfoBtn" type="button" class="btn-info">Info</button>
      </div>
      <div id="inseminationInfoPanel" class="info-panel" hidden>
        <strong><u>About This Section</u></strong><br>
        <br>
        Use this section to track insemination dates. This helps you compare timing against cycle, period, and temperature patterns.<br>
        <br>
        <strong>How to use it:</strong><br>
        1. Log each insemination date on the day it occurs.<br>
        2. Add every relevant date to keep your timeline complete.<br>
        3. Review these markers on the chart alongside period and temperature data.<br>
        <br>
        <strong>Helpful tip:</strong><br>
        If you are trying to conceive, sharing this timeline with your medical professional can support more personalized guidance.
      </div>
      <form id="inseminationForm">
        <div class="row">
          <label>Insemination Date<input id="inseminationDate" type="date" required></label>
          <div style="display:grid;align-items:end;"><button class="btn-main" type="submit">Save Insemination Date</button></div>
        </div>
      </form>
      <p class="muted">Insemination dates are marked on the chart.</p>
    </section>
    <section class="card">
      <div class="chart-header">
        <h2 class="section-title" style="margin:0;">Trend Log</h2>
        <div id="chartRangeTabs" class="chart-range-tabs" role="tablist" aria-label="Chart range">
          <button type="button" class="range-tab active" data-range="30">1M</button>
          <button type="button" class="range-tab" data-range="90">3M</button>
          <button type="button" class="range-tab" data-range="183">6M</button>
          <button type="button" class="range-tab" data-range="365">12M</button>
          <button type="button" class="range-tab" data-range="all">All</button>
        </div>
      </div>
      <div class="chart-wrap"><div id="chartInner" class="chart-inner"><svg id="tempChart" viewBox="0 0 800 280" preserveAspectRatio="none" aria-label="Basal temperature chart"></svg></div></div>
      <div id="chartHint" class="muted"></div>
      <div class="insight-head">
        <h3 style="margin:0;font-size:0.95rem;color:#355f59;">Insight Calculations</h3>
        <button id="insightInfoBtn" type="button" class="btn-info">Info</button>
      </div>
      <div id="insightInfoPanel" class="info-panel" hidden>
        <strong><u>How to read these insights</u></strong><br>
        <br>
        <strong>Last Temp:</strong> Your most recent basal temperature entry.<br>
        <strong>Average Cycle:</strong> The average number of days between your period start dates.<br>
        <strong>Next Period (Estimate):</strong> A predicted date based on your average cycle length.<br>
        <strong>Ovulation Estimate:</strong> Estimated as about 14 days before your predicted next period, based on a common luteal-phase pattern.<br>
        <br>
        <strong>What this does not use:</strong> This estimate does not currently use cervical mucus, LH tests, or symptom tracking, and it does not medically confirm ovulation from temperature alone.<br>
        <br>
        <strong>Important:</strong> This is a guidance tool, not medical advice or a diagnosis.
      </div>
      <div class="insight-grid" id="insightGrid"></div>
      <p class="muted">Ovulation estimate is based on average cycle length and should not be treated as medical advice.</p>
    </section>
    <section class="card">
      <h3 class="section-title">Recent Entries</h3>
      <button id="exportBtn" type="button" class="btn-light">Export Data (JSON)</button>
      <p class="list-title">Temperature Entries</p>
      <div class="list" id="tempsList"></div>
      <p class="list-title">Period Entries</p>
      <div class="list" id="periodsList"></div>
      <p class="list-title">Insemination Entries</p>
      <div class="list" id="inseminationsList"></div>
    </section>
  </main>

  <script>
    const STORAGE_KEY = "wellness-check-v1";
    const DAY_MS = 24 * 60 * 60 * 1000;
    const state = loadState();

    const tempForm = document.getElementById("tempForm");
    const inseminationForm = document.getElementById("inseminationForm");
    const exportBtn = document.getElementById("exportBtn");

    const tempDateEl = document.getElementById("tempDate");
    const tempValueEl = document.getElementById("tempValue");
    const tempUnitEl = document.getElementById("tempUnit");
    const periodStartEl = document.getElementById("periodStart");
    const periodEndEl = document.getElementById("periodEnd");
    const periodStartBtn = document.getElementById("periodStartBtn");
    const periodEndBtn = document.getElementById("periodEndBtn");
    const periodDraftStatusEl = document.getElementById("periodDraftStatus");
    const inseminationDateEl = document.getElementById("inseminationDate");

    const tempsListEl = document.getElementById("tempsList");
    const periodsListEl = document.getElementById("periodsList");
    const inseminationsListEl = document.getElementById("inseminationsList");
    const chartEl = document.getElementById("tempChart");
    const chartInnerEl = document.getElementById("chartInner");
    const chartRangeTabsEl = document.getElementById("chartRangeTabs");
    const chartHintEl = document.getElementById("chartHint");
    const insightGridEl = document.getElementById("insightGrid");
    const insightInfoBtn = document.getElementById("insightInfoBtn");
    const insightInfoPanel = document.getElementById("insightInfoPanel");
    const tempInfoBtn = document.getElementById("tempInfoBtn");
    const tempInfoPanel = document.getElementById("tempInfoPanel");
    const periodInfoBtn = document.getElementById("periodInfoBtn");
    const periodInfoPanel = document.getElementById("periodInfoPanel");
    const inseminationInfoBtn = document.getElementById("inseminationInfoBtn");
    const inseminationInfoPanel = document.getElementById("inseminationInfoPanel");
    let selectedChartRange = "30";

    tempDateEl.value = isoToday();
    periodStartEl.value = isoToday();
    periodEndEl.value = isoToday();
    inseminationDateEl.value = isoToday();

    tempForm.addEventListener("submit", (event) => {
      event.preventDefault();
      const date = tempDateEl.value;
      const value = Number(tempValueEl.value);
      const unit = tempUnitEl.value;
      if (!date || Number.isNaN(value)) return;

      const existing = state.temperatures.find((t) => t.date === date);
      if (existing) {
        existing.value = value;
        existing.unit = unit;
      } else {
        state.temperatures.push({ date, value, unit });
      }

      sortTemps();
      saveState();
      tempValueEl.value = "";
      render();
    });

    periodStartBtn.addEventListener("click", () => {
      const start = periodStartEl.value;
      if (!start) {
        alert("Choose a period start date first.");
        return;
      }
      if (state.periodDraftStart) {
        alert("An active period start already exists. Log the end date before starting a new one.");
        return;
      }

      state.periodDraftStart = start;
      saveState();
      render();
    });

    periodEndBtn.addEventListener("click", () => {
      const end = periodEndEl.value;
      if (!end) {
        alert("Choose a period end date first.");
        return;
      }
      if (!state.periodDraftStart) {
        alert("Log a period start date first.");
        return;
      }
      if (new Date(state.periodDraftStart) > new Date(end)) {
        alert("End date cannot be before the active start date.");
        return;
      }

      const existing = state.periods.find((p) => p.start === state.periodDraftStart && p.end === end);
      if (!existing) {
        state.periods.push({ start: state.periodDraftStart, end });
      }
      state.periodDraftStart = null;
      sortPeriods();
      saveState();
      render();
    });

    inseminationForm.addEventListener("submit", (event) => {
      event.preventDefault();
      const date = inseminationDateEl.value;
      if (!date) return;

      const exists = state.inseminations.some((entry) => entry.date === date);
      if (!exists) {
        state.inseminations.push({ date });
      }

      sortInseminations();
      saveState();
      render();
    });

    exportBtn.addEventListener("click", () => {
      const blob = new Blob([JSON.stringify(state, null, 2)], { type: "application/json" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = `wellness-check-export-${isoToday()}.json`;
      link.click();
      URL.revokeObjectURL(link.href);
    });

    chartRangeTabsEl.addEventListener("click", (event) => {
      const button = event.target.closest("[data-range]");
      if (!button) return;
      selectedChartRange = button.getAttribute("data-range");
      chartRangeTabsEl.querySelectorAll(".range-tab").forEach((tab) => {
        tab.classList.toggle("active", tab === button);
      });
      renderChart();
    });

    insightInfoBtn.addEventListener("click", () => {
      insightInfoPanel.hidden = !insightInfoPanel.hidden;
    });

    tempInfoBtn.addEventListener("click", () => {
      tempInfoPanel.hidden = !tempInfoPanel.hidden;
    });

    periodInfoBtn.addEventListener("click", () => {
      periodInfoPanel.hidden = !periodInfoPanel.hidden;
    });

    inseminationInfoBtn.addEventListener("click", () => {
      inseminationInfoPanel.hidden = !inseminationInfoPanel.hidden;
    });

    function loadState() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return { temperatures: [], periods: [], inseminations: [], periodDraftStart: null };
      try {
        const parsed = JSON.parse(raw);
        return {
          temperatures: Array.isArray(parsed.temperatures) ? parsed.temperatures : [],
          periods: Array.isArray(parsed.periods) ? parsed.periods : [],
          inseminations: Array.isArray(parsed.inseminations) ? parsed.inseminations : [],
          periodDraftStart: typeof parsed.periodDraftStart === "string" ? parsed.periodDraftStart : null
        };
      } catch {
        return { temperatures: [], periods: [], inseminations: [], periodDraftStart: null };
      }
    }

    function saveState() { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
    function sortTemps() { state.temperatures.sort((a, b) => new Date(a.date) - new Date(b.date)); }
    function sortPeriods() { state.periods.sort((a, b) => new Date(b.start) - new Date(a.start)); }
    function sortInseminations() { state.inseminations.sort((a, b) => new Date(a.date) - new Date(b.date)); }
    function isoToday() { return new Date().toISOString().slice(0, 10); }

    function formatDate(input) {
      const d = new Date(input + "T00:00:00");
      return d.toLocaleDateString(undefined, { year: "numeric", month: "short", day: "numeric" });
    }
    function formatShortDate(input) {
      const d = new Date(input + "T00:00:00");
      return d.toLocaleDateString("en-US", { month: "numeric", day: "numeric", year: "2-digit" });
    }

    function cToF(c) { return (c * 9 / 5) + 32; }
    function toFahrenheit(entry) { return entry.unit === "C" ? cToF(entry.value) : entry.value; }
    function normalizeChartTemps(entries) {
      return entries.map((t) => ({ ...t, chartValue: toFahrenheit(t) }));
    }

    function monthKeyFromISO(isoDate) {
      return isoDate.slice(0, 7);
    }

    function monthLabelFromKey(monthKey) {
      const d = new Date(`${monthKey}-01T00:00:00`);
      return d.toLocaleDateString(undefined, { month: "long", year: "numeric" });
    }

    function monthNameFromKey(monthKey) {
      const d = new Date(`${monthKey}-01T00:00:00`);
      return d.toLocaleDateString(undefined, { month: "long" });
    }

    function groupByMonth(entries, getDateISO) {
      const groups = {};
      entries.forEach((entry) => {
        const key = monthKeyFromISO(getDateISO(entry));
        if (!groups[key]) groups[key] = [];
        groups[key].push(entry);
      });
      return groups;
    }

    function groupMonthKeysByYear(monthKeys) {
      const years = {};
      monthKeys.forEach((monthKey) => {
        const yearKey = monthKey.slice(0, 4);
        if (!years[yearKey]) years[yearKey] = [];
        years[yearKey].push(monthKey);
      });
      return years;
    }

    function renderTempsList() {
      if (!state.temperatures.length) {
        tempsListEl.innerHTML = "<p class='muted'>No temperature entries yet.</p>";
        return;
      }

      const ordered = [...state.temperatures].reverse();
      const grouped = groupByMonth(ordered, (entry) => entry.date);
      const monthKeys = Object.keys(grouped).sort((a, b) => b.localeCompare(a));
      const byYear = groupMonthKeysByYear(monthKeys);
      const yearKeys = Object.keys(byYear).sort((a, b) => b.localeCompare(a));

      tempsListEl.innerHTML = yearKeys.map((yearKey, yearIdx) => {
        const months = byYear[yearKey];
        const yearCount = months.reduce((sum, monthKey) => sum + grouped[monthKey].length, 0);

        const monthsHtml = months.map((monthKey, monthIdx) => {
          const rows = grouped[monthKey].map((entry) => `
            <div class="entry">
              <div><strong>${entry.value.toFixed(2)} ${entry.unit}</strong><small>${formatDate(entry.date)}</small></div>
              <button type="button" data-delete-temp="${entry.date}">Delete</button>
            </div>
          `).join("");

          return `
            <details class="month-group" ${yearIdx === 0 && monthIdx === 0 ? "open" : ""}>
              <summary>
                <span>${monthNameFromKey(monthKey)}</span>
                <span class="count">${grouped[monthKey].length} entries</span>
              </summary>
              <div class="month-entries">${rows}</div>
            </details>
          `;
        }).join("");

        return `
          <details class="year-group" ${yearIdx === 0 ? "open" : ""}>
            <summary>
              <span>${yearKey}</span>
              <span class="count">${yearCount} entries</span>
            </summary>
            <div class="year-entries">${monthsHtml}</div>
          </details>
        `;
      }).join("");

      tempsListEl.querySelectorAll("[data-delete-temp]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const date = btn.getAttribute("data-delete-temp");
          state.temperatures = state.temperatures.filter((t) => t.date !== date);
          saveState();
          render();
        });
      });
    }

    function renderPeriodsList() {
      if (!state.periods.length) {
        periodsListEl.innerHTML = state.periodDraftStart
          ? `<div class="entry"><div><strong>Active period started: ${formatDate(state.periodDraftStart)}</strong><small>Waiting for end date</small></div></div>`
          : "<p class='muted'>No period ranges yet.</p>";
        return;
      }

      const ordered = [...state.periods];
      const grouped = groupByMonth(ordered, (entry) => entry.start);
      const monthKeys = Object.keys(grouped).sort((a, b) => b.localeCompare(a));
      const byYear = groupMonthKeysByYear(monthKeys);
      const yearKeys = Object.keys(byYear).sort((a, b) => b.localeCompare(a));

      const listHtml = yearKeys.map((yearKey, yearIdx) => {
        const months = byYear[yearKey];
        const yearCount = months.reduce((sum, monthKey) => sum + grouped[monthKey].length, 0);

        const monthsHtml = months.map((monthKey, monthIdx) => {
          const rows = grouped[monthKey].map((entry) => {
            const id = `${entry.start}|${entry.end}`;
            return `
              <div class="entry">
                <div><strong>Period: ${formatDate(entry.start)} - ${formatDate(entry.end)}</strong></div>
                <button type="button" data-delete-period="${id}">Delete</button>
              </div>
            `;
          }).join("");

          return `
            <details class="month-group" ${yearIdx === 0 && monthIdx === 0 ? "open" : ""}>
              <summary>
                <span>${monthNameFromKey(monthKey)}</span>
                <span class="count">${grouped[monthKey].length} entries</span>
              </summary>
              <div class="month-entries">${rows}</div>
            </details>
          `;
        }).join("");

        return `
          <details class="year-group" ${yearIdx === 0 ? "open" : ""}>
            <summary>
              <span>${yearKey}</span>
              <span class="count">${yearCount} entries</span>
            </summary>
            <div class="year-entries">${monthsHtml}</div>
          </details>
        `;
      }).join("");

      const activeHtml = state.periodDraftStart
        ? `<div class="entry"><div><strong>Active period started: ${formatDate(state.periodDraftStart)}</strong><small>Waiting for end date</small></div></div>`
        : "";
      periodsListEl.innerHTML = `${activeHtml}${listHtml}`;

      periodsListEl.querySelectorAll("[data-delete-period]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const id = btn.getAttribute("data-delete-period");
          const [start, end] = id.split("|");
          state.periods = state.periods.filter((p) => !(p.start === start && p.end === end));
          saveState();
          render();
        });
      });
    }

    function renderInseminationsList() {
      if (!state.inseminations.length) {
        inseminationsListEl.innerHTML = "<p class='muted'>No insemination entries yet.</p>";
        return;
      }

      const ordered = [...state.inseminations].reverse();
      const grouped = groupByMonth(ordered, (entry) => entry.date);
      const monthKeys = Object.keys(grouped).sort((a, b) => b.localeCompare(a));
      const byYear = groupMonthKeysByYear(monthKeys);
      const yearKeys = Object.keys(byYear).sort((a, b) => b.localeCompare(a));

      inseminationsListEl.innerHTML = yearKeys.map((yearKey, yearIdx) => {
        const months = byYear[yearKey];
        const yearCount = months.reduce((sum, monthKey) => sum + grouped[monthKey].length, 0);

        const monthsHtml = months.map((monthKey, monthIdx) => {
          const rows = grouped[monthKey].map((entry) => {
            return `
              <div class="entry">
                <div><strong>Insemination: ${formatDate(entry.date)}</strong></div>
                <button type="button" data-delete-insemination="${entry.date}">Delete</button>
              </div>
            `;
          }).join("");

          return `
            <details class="month-group" ${yearIdx === 0 && monthIdx === 0 ? "open" : ""}>
              <summary>
                <span>${monthNameFromKey(monthKey)}</span>
                <span class="count">${grouped[monthKey].length} entries</span>
              </summary>
              <div class="month-entries">${rows}</div>
            </details>
          `;
        }).join("");

        return `
          <details class="year-group" ${yearIdx === 0 ? "open" : ""}>
            <summary>
              <span>${yearKey}</span>
              <span class="count">${yearCount} entries</span>
            </summary>
            <div class="year-entries">${monthsHtml}</div>
          </details>
        `;
      }).join("");

      inseminationsListEl.querySelectorAll("[data-delete-insemination]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const date = btn.getAttribute("data-delete-insemination");
          state.inseminations = state.inseminations.filter((entry) => entry.date !== date);
          saveState();
          render();
        });
      });
    }

    function cycleInsights() {
      const starts = [...state.periods].map((p) => p.start).sort((a, b) => new Date(a) - new Date(b));
      if (starts.length < 2) return { averageCycle: null, nextPeriod: null, ovulationEstimate: null };

      const lengths = [];
      for (let i = 1; i < starts.length; i += 1) {
        const prev = new Date(starts[i - 1]);
        const curr = new Date(starts[i]);
        lengths.push(Math.round((curr - prev) / DAY_MS));
      }

      const averageCycle = Math.round(lengths.reduce((sum, n) => sum + n, 0) / lengths.length);
      const lastStart = new Date(starts[starts.length - 1]);
      const nextPeriod = new Date(lastStart.getTime() + averageCycle * DAY_MS);
      const ovulationEstimate = new Date(nextPeriod.getTime() - 14 * DAY_MS);
      return { averageCycle, nextPeriod, ovulationEstimate };
    }

    function renderInsights() {
      const latestTemp = state.temperatures[state.temperatures.length - 1] || null;
      const insight = cycleInsights();

      const items = [
        { key: "Last Temp", value: latestTemp ? `${latestTemp.value.toFixed(2)} ${latestTemp.unit}` : "-" },
        { key: "Avg Cycle", value: insight.averageCycle ? `${insight.averageCycle} days` : "-" },
        { key: "Est. Ovulation", value: insight.ovulationEstimate ? formatDate(insight.ovulationEstimate.toISOString().slice(0, 10)) : "-" },
        { key: "Next Period", value: insight.nextPeriod ? formatDate(insight.nextPeriod.toISOString().slice(0, 10)) : "-" }
      ];

      insightGridEl.innerHTML = items.map((item) => `
        <article class="insight"><div class="k">${item.key}</div><div class="v">${item.value}</div></article>
      `).join("");
    }

    function renderChart() {
      if (!state.temperatures.length && !state.periods.length && !state.inseminations.length && !state.periodDraftStart) {
        chartEl.innerHTML = "";
        chartEl.style.width = "100%";
        chartInnerEl.style.width = "100%";
        chartHintEl.textContent = "Add temperature, period, or insemination entries to populate the chart.";
        return;
      }

      const chartData = normalizeChartTemps(state.temperatures);
      const tempDates = chartData.map((t) => new Date(t.date));
      const periodStarts = state.periods.map((p) => new Date(p.start));
      const periodEnds = state.periods.map((p) => new Date(p.end));
      const draftStartDates = state.periodDraftStart ? [new Date(state.periodDraftStart)] : [];
      const draftEndDates = state.periodDraftStart ? [new Date(isoToday())] : [];
      const inseminationDates = state.inseminations.map((entry) => new Date(entry.date));
      const allDates = [...tempDates, ...periodStarts, ...periodEnds, ...draftStartDates, ...draftEndDates, ...inseminationDates];
      const maxDate = new Date(Math.max(...allDates.map((d) => d.getTime())));
      const rangeValue = selectedChartRange;
      const days = rangeValue === "all" ? null : Number(rangeValue);
      const minDate = days
        ? new Date(maxDate.getTime() - days * DAY_MS)
        : new Date(Math.min(...allDates.map((d) => d.getTime())));
      const maxRangeDate = maxDate;
      const display = chartData.filter((t) => {
        const d = new Date(t.date);
        return d >= minDate && d <= maxRangeDate;
      });

      const hasPeriodInRange = state.periods.some((p) => new Date(p.end) >= minDate && new Date(p.start) <= maxRangeDate);
      const hasDraftPeriodInRange = state.periodDraftStart
        ? new Date(isoToday()) >= minDate && new Date(state.periodDraftStart) <= maxRangeDate
        : false;
      const hasInseminationInRange = state.inseminations.some((entry) => {
        const d = new Date(entry.date);
        return d >= minDate && d <= maxRangeDate;
      });

      if (!display.length && !hasPeriodInRange && !hasDraftPeriodInRange && !hasInseminationInRange) {
        chartEl.innerHTML = "";
        chartEl.style.width = "100%";
        chartInnerEl.style.width = "100%";
        chartHintEl.textContent = "No temperature, period, or insemination entries in this range.";
        return;
      }

      const height = 280;
      const padL = 42;
      const padR = 14;
      const padT = 14;
      const padB = 28;
      const innerH = height - padT - padB;

      const minTemp = Math.min(...display.map((d) => d.chartValue));
      const maxTemp = Math.max(...display.map((d) => d.chartValue));
      const yMin = minTemp - 0.15;
      const yMax = maxTemp + 0.15;

      const minXDate = minDate;
      const maxXDate = maxRangeDate;
      const dateSpan = Math.max((maxXDate - minXDate) / DAY_MS, 1);
      const pxPerDay = 14;
      const dynamicInnerW = dateSpan * pxPerDay;
      const innerW = Math.max(744, dynamicInnerW);
      const width = padL + padR + innerW;

      chartEl.setAttribute("viewBox", `0 0 ${width} ${height}`);
      chartInnerEl.style.width = `${width}px`;
      chartEl.style.width = "100%";
      chartEl.style.height = `${height}px`;

      const xForDate = (iso) => {
        const d = new Date(iso);
        const dayOffset = (d - minXDate) / DAY_MS;
        return padL + (dayOffset / dateSpan) * innerW;
      };

      const yForTemp = (val) => {
        const t = (val - yMin) / (yMax - yMin);
        return padT + (1 - t) * innerH;
      };

      const ticks = 5;
      const yGrid = Array.from({ length: ticks }, (_, i) => {
        const ratio = i / (ticks - 1);
        const val = yMax - ratio * (yMax - yMin);
        const y = padT + ratio * innerH;
        return `
          <line x1="${padL}" y1="${y}" x2="${width - padR}" y2="${y}" stroke="#dce9e4" stroke-width="1" />
          <text x="${padL - 6}" y="${y + 3}" text-anchor="end" font-size="10" fill="#5f7f7b">${val.toFixed(2)}</text>
        `;
      }).join("");

      const monthBoundaries = [];
      let boundary = new Date(minXDate.getFullYear(), minXDate.getMonth(), 1);
      if (boundary <= minXDate) {
        boundary.setMonth(boundary.getMonth() + 1);
      }
      while (boundary <= maxXDate) {
        monthBoundaries.push(new Date(boundary));
        boundary.setMonth(boundary.getMonth() + 1);
      }

      const monthEdges = [new Date(minXDate), ...monthBoundaries, new Date(maxXDate)];
      const monthBands = monthEdges.slice(0, -1).map((edgeStart, idx) => {
        const edgeEnd = monthEdges[idx + 1];
        const x1 = xForDate(edgeStart.toISOString().slice(0, 10));
        const x2 = xForDate(edgeEnd.toISOString().slice(0, 10));
        const fill = idx % 2 === 0 ? "#f7fbfa" : "#fcfffe";
        return `<rect x="${x1}" y="${padT}" width="${Math.max(x2 - x1, 1)}" height="${innerH}" fill="${fill}" opacity="0.8"></rect>`;
      }).join("");

      const monthLines = monthBoundaries.map((d) => {
        const x = xForDate(d.toISOString().slice(0, 10));
        return `<line x1="${x}" y1="${padT}" x2="${x}" y2="${padT + innerH}" stroke="#cbded8" stroke-width="1.2" opacity="0.95"></line>`;
      }).join("");

      const monthNameLabels = monthEdges.slice(0, -1).map((edgeStart, idx) => {
        const edgeEnd = monthEdges[idx + 1];
        const x1 = xForDate(edgeStart.toISOString().slice(0, 10));
        const x2 = xForDate(edgeEnd.toISOString().slice(0, 10));
        const widthPx = x2 - x1;
        if (widthPx < 44) return "";
        const centerX = x1 + (widthPx / 2);
        const label = edgeStart.toLocaleDateString(undefined, { month: "short", year: "numeric" });
        return `<text x="${centerX}" y="${height - 19}" text-anchor="middle" font-size="9" font-weight="600" fill="#3f6560">${label}</text>`;
      }).join("");

      const weekBands = [];
      const weekLines = [];
      const weekLabels = [];
      monthEdges.slice(0, -1).forEach((edgeStart, monthIndex) => {
        const edgeEnd = monthEdges[monthIndex + 1];
        const monthStart = new Date(edgeStart.getFullYear(), edgeStart.getMonth(), 1);

        // Fixed monthly week anchors so each full month maps to W1..W5 consistently.
        const anchors = [1, 8, 15, 22, 29, 36].map((day) => {
          const d = new Date(monthStart);
          d.setDate(day);
          return d;
        });

        for (let i = 0; i < 5; i += 1) {
          const rawStart = anchors[i];
          const rawEnd = anchors[i + 1];
          const segStart = rawStart < edgeStart ? edgeStart : rawStart;
          const segEnd = rawEnd > edgeEnd ? edgeEnd : rawEnd;
          if (segEnd <= segStart) continue;

          const x1 = xForDate(segStart.toISOString().slice(0, 10));
          const x2 = xForDate(segEnd.toISOString().slice(0, 10));
          const widthPx = Math.max(x2 - x1, 1);

          if (widthPx > 12 && i % 2 === 0) {
            weekBands.push(`<rect x="${x1}" y="${padT}" width="${widthPx}" height="${innerH}" fill="#ffffff" opacity="0.22"></rect>`);
          }
          if (i > 0) {
            const lineX = xForDate((rawStart < edgeStart ? edgeStart : rawStart).toISOString().slice(0, 10));
            weekLines.push(`<line x1="${lineX}" y1="${padT}" x2="${lineX}" y2="${padT + innerH}" stroke="#d7e6e1" stroke-width="1" opacity="0.9" stroke-dasharray="3 3"></line>`);
          }

          if (widthPx > 18) {
            const weekLabel = `W${i + 1}`;
            const centerX = x1 + (widthPx / 2);
            const y = padT + innerH - 4;
            weekLabels.push(`<text x="${centerX}" y="${y}" text-anchor="middle" font-size="8" fill="#6f8c88">${weekLabel}</text>`);
          }
        }
      });

      const periodRangesForChart = [...state.periods];
      if (state.periodDraftStart) {
        periodRangesForChart.push({ start: state.periodDraftStart, end: isoToday() });
      }

      const periodRects = periodRangesForChart.map((p) => {
        const start = new Date(p.start);
        const end = new Date(p.end);
        if (end < minXDate || start > maxXDate) return "";

        const clampedStart = start < minXDate ? minXDate : start;
        const clampedEnd = end > maxXDate ? maxXDate : end;
        const x1 = xForDate(clampedStart.toISOString().slice(0, 10));
        const x2 = xForDate(clampedEnd.toISOString().slice(0, 10));
        return `<rect x="${x1}" y="${padT}" width="${Math.max(x2 - x1, 2)}" height="${innerH}" fill="#fde2e7" opacity="0.55"></rect>`;
      }).join("");

      const inseminationMarkers = state.inseminations
        .filter((entry) => {
          const d = new Date(entry.date);
          return d >= minXDate && d <= maxXDate;
        })
        .map((entry) => {
          const x = xForDate(entry.date);
          const yTop = padT + 4;
          const yBottom = padT + innerH;
          return `
            <line x1="${x}" y1="${yTop + 7}" x2="${x}" y2="${yBottom}" stroke="#d97706" stroke-width="1.1" opacity="0.55" stroke-dasharray="4 4"></line>
            <path d="M ${x - 5} ${yTop} L ${x + 5} ${yTop} L ${x} ${yTop + 8} Z" fill="#d97706" opacity="0.9"></path>
          `;
        }).join("");

      const tileW = 50;
      const tileH = 30;
      const connectorPath = display.map((d, i) => {
        const x = xForDate(d.date);
        const y = yForTemp(d.chartValue);
        return `${i === 0 ? "M" : "L"} ${x.toFixed(2)} ${y.toFixed(2)}`;
      }).join(" ");

      const monthlyEntries = {};
      display.forEach((d) => {
        const monthKey = d.date.slice(0, 7);
        if (!monthlyEntries[monthKey]) monthlyEntries[monthKey] = [];
        monthlyEntries[monthKey].push(d);
      });

      const monthlyTopDates = {};
      Object.keys(monthlyEntries).forEach((monthKey) => {
        const top = [...monthlyEntries[monthKey]]
          .sort((a, b) => {
            if (b.chartValue !== a.chartValue) return b.chartValue - a.chartValue;
            return new Date(a.date) - new Date(b.date);
          })
          .slice(0, 7);

        const minPinnedSpacingPx = tileW + 8;
        const maxPinnedPerMonth = 3;
        const pinned = [];

        top.forEach((entry) => {
          if (pinned.length >= maxPinnedPerMonth) return;
          const x = xForDate(entry.date);
          const overlaps = pinned.some((kept) => Math.abs(kept.x - x) < minPinnedSpacingPx);
          if (!overlaps) {
            pinned.push({ date: entry.date, x });
          }
        });

        if (!pinned.length && top.length) {
          pinned.push({ date: top[0].date, x: xForDate(top[0].date) });
        }

        monthlyTopDates[monthKey] = new Set(pinned.map((entry) => entry.date));
      });

      const pointMarks = display.map((d) => {
        const centerX = xForDate(d.date);
        const centerY = yForTemp(d.chartValue);
        const x = Math.max(padL, Math.min(width - padR - tileW, centerX - (tileW / 2)));
        const y = Math.max(padT, Math.min(padT + innerH - tileH, centerY - tileH - 6));
        const monthKey = d.date.slice(0, 7);
        const pinned = monthlyTopDates[monthKey].has(d.date);
        const pinnedClass = pinned ? " pinned" : "";

        return `
          <g class="point${pinnedClass}">
            <circle cx="${centerX}" cy="${centerY}" r="3.2" fill="#0f766e"></circle>
            ${pinned ? `<circle cx="${centerX}" cy="${centerY}" r="5.2" fill="none" stroke="#ea580c" stroke-width="1.6"></circle>` : ""}
            <g class="value-label">
              <rect x="${x}" y="${y}" width="${tileW}" height="${tileH}" rx="6" fill="#0f766e" />
              <text x="${x + (tileW / 2)}" y="${y + 12}" text-anchor="middle" fill="#ffffff">
                <tspan x="${x + (tileW / 2)}" font-size="9" font-weight="700">${d.chartValue.toFixed(1)}</tspan>
                <tspan x="${x + (tileW / 2)}" dy="11" font-size="8" font-weight="500">${formatShortDate(d.date)}</tspan>
              </text>
            </g>
          </g>
        `;
      }).join("");

      const labelDates = [minXDate, new Date((minXDate.getTime() + maxXDate.getTime()) / 2), maxXDate];
      const xLabels = labelDates.map((d) => {
        const iso = d.toISOString().slice(0, 10);
        return `<text x="${xForDate(iso)}" y="${height - 8}" text-anchor="middle" font-size="10" fill="#5f7f7b">${d.toLocaleDateString(undefined, { month: "short", day: "numeric" })}</text>`;
      }).join("");

      chartEl.innerHTML = `
        <style>
          .point .value-label { opacity: 0; transition: opacity 120ms ease; }
          .point:hover .value-label { opacity: 1; }
          .point.pinned .value-label { opacity: 1; }
        </style>
        <rect x="0" y="0" width="${width}" height="${height}" fill="#fcfffe"></rect>
        ${monthBands}
        ${weekBands.join("")}
        ${yGrid}
        ${weekLines.join("")}
        ${monthLines}
        ${periodRects}
        ${inseminationMarkers}
        ${display.length > 1 ? `<path d="${connectorPath}" fill="none" stroke="#5ea79f" stroke-width="1.8" stroke-linejoin="round" stroke-linecap="round" opacity="0.9"></path>` : ""}
        ${pointMarks}
        ${monthNameLabels}
        ${weekLabels.join("")}
        ${xLabels}
      `;

      chartHintEl.textContent = "Month blocks plus weekly guides (W1-W5) segment each month. Month names are centered under each block. Pink areas show period days. Gold markers show insemination dates. Every day is shown as a dot. Hover dots to reveal values. Orange-ring dots mark top temperature days per month.";
    }

    function render() {
      sortTemps();
      sortPeriods();
      sortInseminations();
      periodDraftStatusEl.textContent = state.periodDraftStart
        ? `Active period started on ${formatDate(state.periodDraftStart)}. Log an end date when it is complete.`
        : "No active period start.";
      renderTempsList();
      renderPeriodsList();
      renderInseminationsList();
      renderChart();
      renderInsights();
    }

    render();

    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        const isLocalDev = location.protocol !== "https:" || location.hostname === "localhost" || location.hostname === "127.0.0.1";

        if (isLocalDev) {
          navigator.serviceWorker.getRegistrations().then((registrations) => {
            registrations.forEach((registration) => registration.unregister());
          });

          if ("caches" in window) {
            caches.keys().then((keys) => Promise.all(keys.map((key) => caches.delete(key))));
          }
          return;
        }

        navigator.serviceWorker.register("service-worker.js").catch(() => {
          // Silent failure is acceptable for local development.
        });
      });
    }
  </script>
</body>
</html>
